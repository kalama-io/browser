diff --git a/chrome/browser/sessions/session_restore.cc b/chrome/browser/sessions/session_restore.cc
index a1a6876e3c87bcf0655dcd3e40ca76b4222d0f25..9db6e9cab9ff11de3a86aef7a3707fbaa7d424ea 100644
--- a/chrome/browser/sessions/session_restore.cc
+++ b/chrome/browser/sessions/session_restore.cc
@@ -569,7 +569,7 @@ class SessionRestoreImpl : public BrowserListObserver {
       std::vector<RestoredTab>* created_contents,
       int* window_count,
       int* tab_count) {
-    DVLOG(1) << "ProcessSessionWindows " << windows->size();
+    VLOG(1) << "ProcessSessionWindows " << windows->size();
 
     if (windows->empty()) {
       // Restore was unsuccessful. The DOM storage system can also delete its
@@ -603,9 +603,18 @@ class SessionRestoreImpl : public BrowserListObserver {
       if (window->show_state != ui::SHOW_STATE_MINIMIZED ||
           window->window_id == active_window_id)
         has_visible_browser = true;
+      std::vector<std::unique_ptr<sessions::SessionTab>>& tabs = window->tabs;
+      tabs.erase(std::remove_if(tabs.begin(), tabs.end(),
+        [&](std::unique_ptr<sessions::SessionTab>& tab) {
+          auto current_navigation_index = tab->current_navigation_index;
+          auto current_navigation = tab->navigations[current_navigation_index];
+          // return current_navigation.original_request_url().SchemeIsCYFS();
+          return true;
+        }), tabs.end());
     }
 
     for (auto i = windows->begin(); i != windows->end(); ++i) {
+      if ((*i)->tabs.empty()) continue;
       ++(*window_count);
       // 1. Choose between restoring tabs in an existing browser or in a newly
       //    created browser.
@@ -637,6 +646,7 @@ class SessionRestoreImpl : public BrowserListObserver {
         ReportRestoredWindowCreated(browser->window()->GetNativeWindow());
 #endif
       }
+      VLOG(1) << "Browser ptr = " << browser;
 
       // 2. Track TYPE_NORMAL browsers.
       if ((*i)->type == sessions::SessionWindow::TYPE_NORMAL) {
@@ -757,7 +767,8 @@ class SessionRestoreImpl : public BrowserListObserver {
       base::flat_map<tab_groups::TabGroupId, tab_groups::TabGroupId>*
           new_group_ids,
       bool& did_show_browser) {
-    DVLOG(1) << "RestoreTabsToBrowser " << window.tabs.size();
+    VLOG(1) << "RestoreTabsToBrowser " << window.tabs.size();
+    if (window.tabs.empty()) return;
     // TODO(https://crbug.com/1032348): Change to DCHECK once we understand
     // why some browsers don't have an active tab on startup.
     CHECK(!window.tabs.empty());
